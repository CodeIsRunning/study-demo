                                JVM
首先程序是跑在虚拟机上的而不是操作系统上的所以才能在不同的系统中夸平台

jvm为啥能运行java?  
    先看下它都有哪些东西 一套字节码指令集、一组寄存器、一个栈、垃圾回收器、堆和方法域。
    我们写的代码一般都是.java文件 经过通过编译器生成一个.class 文件  jvm就是通过这个.class文件解释成了机器码 这样机器就能执行了
    而且一个运行的程序就会对应一个jvm的实例  也就是说你每启动一个java程序jvm就会初始化一个实例 知道程序正常或异常关闭 此时这个
    jvm实例才会消失

jvm在内存中分为哪几部分？
    里面有两大阵营 
    1、跟别人共享的
        堆和方法区 。 堆里放的一般是对象  方法区顾名思义咯
    2、不跟别人共享的
        程序计数器、jvm栈、本地方法区  。 程序计数器表示当前执行到了哪里的一个标记   jvm栈这里面有一批栈帧，当某个方法执行的时
        候会把他的一些信息保存到里面 比如返回的东西、局部的一些参数。。  本地方法区就是jvm使用native用的一块地方    
    这样大概就知道程序运行的时候我们编写的代码分布 
    对象在堆里   方法和常量基本都在方法区
    
jvm垃圾的清理回收
    怎么确定某系就是垃圾呢？
        1、看看是否有与之关联的在用
        2、看看是否可达  好比串门某条路不可达 那可不就废了该清理了
    回收算法：
        标记回收:
            先标记这个需要回收的 然后在回收 这样搞久了以后整个回收内存就会变的支离破碎 为整理带来不小的麻烦
        复制法：
            为了解决内存碎片化 发明了复制发 复制发就是把回收区域分成两块用一块留一块 要回收的时候把用的那一块存活的复制到空的
            那一块上去，留下的清理一下  这样刚才使用的那块就空下来了 就这样循环往复 就是利用率有点低
        标记整理法：
            结合前两种的麻烦和浪费 大佬们又发明了标记整理 把存活的放在一角 存活边界线之外的全部清理掉
        分代回收：
            jvm在堆里分两大块 新生代和老年代  新生代里面的对象生成消亡很快，新生代里又分为了三块eden、servicorFrom、ServicorTo
            回收主要在这三块的操作 首先会把前两块的的活着的放到第三块，把他们的年龄加一 也就是存活的时间如果 有达到老年的级别，就把它丢
            到老年区 这时候前两部分留的都是一些废品就可以清理掉了  然后在把第三块和第二块互换  这样第三块和第一块就是空的 就这样生与死
            轮回不止 有点生有的死  这样老年代一直积累一直积累 久了就会出现我们经常遇到的oom 内存溢出，还在jdk8加了改进移除了老年区加了
            元数据 就是放不下的可以放到本地内存中 其实还是那个老年区只不过地方变大了
    
    
    

    


 
